// var thresholds = {t: 0.899, f: 0.0499, theta: 0.899, theta_likely : 0.499}
// var thresholds = {t: 0.899, f: 0.0499, theta: 0.749, theta_likely : 0.499}

// @arg table: probability distribution
// @arg variables <str>, e.g.["A", "C"]
// computes the marginal probability of P(X, Y, ..) for all input variables
var marginal = cache(function(table, variables){
  var tokens = table.support()
  var all_x = map(function(v){
    v.indexOf("-") != -1 ? filter(function(k){k.indexOf(v) != -1}, tokens) :
                           filter(function(k){k.indexOf("-"+v) == -1}, tokens)
  }, variables)
  var xs = intersect_arrays(all_x)

  return reduce(function(x, acc){acc + Math.exp(table.score(x))}, 0, xs)
})

var conditional_probs = cache(function(table){
  return {"P(C|A)" : marginal(table, ["A", "C"]) / marginal(table, ["A"]),
          "P(C|-A)": marginal(table, ["-A", "C"]) / marginal(table, ["-A"]),
          "P(A|C)" : marginal(table, ["A", "C"]) / marginal(table, ["C"]),
          "P(A|-C)": marginal(table, ["A", "-C"]) / marginal(table, ["-C"]),
          "P(C|Da)": marginal(table, ["C", "Da"]) / marginal(table, ["Da"]),
          "P(C|Db)": marginal(table, ["C", "Db"]) / marginal(table, ["Db"]),
          "P(C|Dna)": marginal(table, ["C", "Dna"]) / marginal(table, ["Dna"]),
          "P(C|B)" : marginal(table, ["B", "C"]) / marginal(table, ["B"]),
          "P(C|A,B)": marginal(table, ["C", "A", "B"]) / marginal(table, ["A", "B"]),
          "P(C|A,-B)": marginal(table, ["C", "A", "-B"]) / marginal(table, ["A", "-B"]),
          "P(C|-A,B)": marginal(table, ["C", "-A", "B"]) / marginal(table, ["-A", "B"]),
          "P(C|-A,-B)": marginal(table, ["C", "-A", "-B"]) / marginal(table, ["-A", "-B"])
        }
}, 10000)

var connect_variables = function(var_powerset, connective){
  var connected_vars = mapIndexed(function(idx, first_set){
    var rest_sets = var_powerset.slice(idx+1)
    var sets_to_pair = filter(function(rest_i){
      all(function(x){
        rest_i.indexOf(x) == -1 && rest_i.indexOf(negate(x)) == -1
      }, first_set)
    }, rest_sets)
    var elems_to_pair = map(function(set_i){set_i.join(" and ")}, sets_to_pair)

    var antecedent = first_set.join(" and ")
    var ifs = reduce(function(key, acc){
      acc.concat([antecedent + connective + key, key + connective + antecedent])
    }, [], elems_to_pair)
    return ifs
  }, var_powerset)

  var filtered = filter(function(arr){arr.length >= 1}, connected_vars)
  var connected_vars = reduce(function(arr, acc){
    acc.concat(arr)
  }, [], filtered)

  return connected_vars
}


// ----- UTTERANCES ----- //
var make_utterances = function(var_powerset){
  var conj_literals = map(function(set_i){set_i.join(" and ")}, var_powerset)
  var literals = filter(function(utt){utt.indexOf(" and ") == -1}, conj_literals)
  var likelys = map(function(lit){"likely " + lit}, literals)
  var conditionals = connect_variables(var_powerset, " > ")
  var utterances = conj_literals.concat(likelys.concat(conditionals))
  return utterances
}

var utterance_probs = cache(function(utterance, Table){
  if(utterance.indexOf(">") != -1){
    var components = utterance.split(" > ")
    var antecedent = components[0].split(" and ").join("")
    var consequent = components[1].split(" and ").join("")
    return marginal(Table, [antecedent, consequent]) /
           marginal(Table, [antecedent])
  }
  else if(utterance.includes("likely")){
    var u = utterance.slice("likely ".length)
    return marginal(Table, [u])
  } else if(utterance.includes("and")){
    var components = utterance.split(" and ")
    return marginal(Table, components)
  }
  else {
    return marginal(Table, [utterance])
  }
})

var costs = cache(function(utt){
  if(globalStore.utterances.indexOf(utt)== -1){error('unknown utterance ' + utt)}
  var c1 = utt.includes(' > ') ? globalStore.cost_conditional : 0
  var c2 = (utt.split(' and ').length - 1) * (globalStore.cost_conditional/2)
  var c3 = utt.split('-').length > 1 ?  (globalStore.cost_conditional/4) : 0
  var c4 = utt.includes('likely') ? (globalStore.cost_conditional/5) : 0
  return c1 + c2 + c3 + c4
}, 10000)


// Meaning ------------------------------------------------------------------
var meaning = cache(function(utterance, table){
 var p = utterance_probs(utterance, table)
 var u_applicable =
  utterance == "" ? true :
  (utterance.includes('likely') ?
  p >= globalStore.thresholds.theta_likely : p >= globalStore.thresholds.theta)

 // display(utterance + " " + p + " " + u_applicable)
 return u_applicable
})


var speaker_conditions = function(utt, Table, probs) {
  // p_rooij/p_delta larger than a threshold
  if(utt == "p_rooij") {
    return probs.p_rooij >= 0.9
  } else if(utt == "p_delta") {
    return probs.p_delta > 0 && probs.p_c_given_a >= 0.9;
  } else if(utt == "uncertainAandC") {
    let uncC = (probs.pc > (1 - globalStore.thresholds.theta)) && (probs.pc < globalStore.thresholds.theta)
    let uncA = (probs.pa > (1 - globalStore.thresholds.theta)) && (probs.pa < globalStore.thresholds.theta)
    return uncA && uncC;

  } else if(utt == "certainAandC") {
    let certA = (probs.pa >= globalStore.thresholds.theta) || (probs.pa <= 1 - globalStore.thresholds.theta)
    let certC = (probs.pc >= globalStore.thresholds.theta) || (probs.pc <= 1 - globalStore.thresholds.theta);
    return certA && certC;

  } else if(utt != ""){
    // condition on meaning of given utterance
    return meaning(utt, Table)
  } else {
    // simply accept
    return true
  }
}

//@return only bayes net
var priorConditionedForSpeaker = function(utt_condition){
  return Infer({model:function(){
    var state = sample(globalStore.state_prior)
    var Table = state["table"]

    let pac = Math.exp(Table.score("AC"))
    let pnac = Math.exp(Table.score("-AC"))
    let pa = pac + Math.exp(Table.score("A-C"))
    let pc = pac + pnac
    let p_c_given_a = pac / pa;
    let p_c_given_na = pnac / (1-pa);
    let p_delta = p_c_given_a - p_c_given_na;
    let p_rooij = p_delta / (1 - p_c_given_na);
    let probs = {pa, pc, p_c_given_a, p_delta, p_rooij}
    condition(speaker_conditions(utt_condition, Table, probs));
    return state.bn
  }});
}
